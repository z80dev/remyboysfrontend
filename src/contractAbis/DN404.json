{"abi":[{"inputs":[],"name":"ApprovalCallerNotOwnerNorApproved","type":"error"},{"inputs":[],"name":"DNAlreadyInitialized","type":"error"},{"inputs":[],"name":"DNNotInitialized","type":"error"},{"inputs":[],"name":"FnSelectorNotRecognized","type":"error"},{"inputs":[],"name":"InsufficientAllowance","type":"error"},{"inputs":[],"name":"InsufficientBalance","type":"error"},{"inputs":[],"name":"InvalidUnit","type":"error"},{"inputs":[],"name":"LinkMirrorContractFailed","type":"error"},{"inputs":[],"name":"MirrorAddressIsZero","type":"error"},{"inputs":[],"name":"SenderNotMirror","type":"error"},{"inputs":[],"name":"TokenDoesNotExist","type":"error"},{"inputs":[],"name":"TotalSupplyOverflow","type":"error"},{"inputs":[],"name":"TransferCallerNotOwnerNorApproved","type":"error"},{"inputs":[],"name":"TransferFromIncorrectOwner","type":"error"},{"inputs":[],"name":"TransferToZeroAddress","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":false,"internalType":"bool","name":"status","type":"bool"}],"name":"SkipNFTSet","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"Transfer","type":"event"},{"stateMutability":"payable","type":"fallback"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"getSkipNFT","outputs":[{"internalType":"bool","name":"result","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"mirrorERC721","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bool","name":"skipNFT","type":"bool"}],"name":"setSkipNFT","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"stateMutability":"payable","type":"receive"}],"contractName":"DN404","deploymentBytecode":{"bytecode":"0x"},"devdoc":{"author":"vectorized.eth (@optimizoor)Quit (@0xQuit)Michael Amadi (@AmadiMichaels)cygaar (@0xCygaar)Thomas (@0xjustadev)Harrison (@PopPunkOnChain)","details":"Note: - The ERC721 data is stored in this base DN404 contract, however a   DN404Mirror contract ***MUST*** be deployed and linked during   initialization. - For ERC20 transfers, the most recently acquired NFT will be burned / transferred out first. - A unit worth of ERC20 tokens equates to a deed to one NFT token.   The skip NFT status determines if this deed is automatically exercised.   An account can configure their skip NFT status.     * If `getSkipNFT(owner) == true`, ERC20 mints / transfers to `owner`       will NOT trigger NFT mints / transfers to `owner` (i.e. deeds are left unexercised).     * If `getSkipNFT(owner) == false`, ERC20 mints / transfers to `owner`       will trigger NFT mints / transfers to `owner`, until the NFT balance of `owner`       is equal to its ERC20 balance divided by the unit (rounded down). - Invariant: `mirror.balanceOf(owner) <= base.balanceOf(owner) / _unit()`. - The gas costs for automatic minting / transferring / burning of NFTs is O(n).   This can exceed the block gas limit.   Applications and users may need to break up large transfers into a few transactions. - This implementation does not support \"safe\" transfers for automatic NFT transfers. - The ERC20 token allowances and ERC721 token / operator approvals are separate. - For MEV safety, users should NOT have concurrently open orders for the ERC20 and ERC721.","errors":{"ApprovalCallerNotOwnerNorApproved()":[{"details":"Thrown when setting an NFT token approval and the caller is not the owner or an approved operator."}],"DNAlreadyInitialized()":[{"details":"Thrown when attempting to double-initialize the contract."}],"DNNotInitialized()":[{"details":"The function can only be called after the contract has been initialized."}],"FnSelectorNotRecognized()":[{"details":"The function selector is not recognized."}],"InsufficientAllowance()":[{"details":"Thrown when a spender attempts to transfer tokens with an insufficient allowance."}],"InsufficientBalance()":[{"details":"Thrown when attempting to transfer or burn more tokens than sender's balance."}],"InvalidUnit()":[{"details":"The unit must be greater than zero and less than `2**96`."}],"LinkMirrorContractFailed()":[{"details":"Thrown when the link call to the mirror contract reverts."}],"MirrorAddressIsZero()":[{"details":"Thrown when the mirror address provided for initialization is the zero address."}],"SenderNotMirror()":[{"details":"Thrown when the caller for a fallback NFT function is not the mirror contract."}],"TokenDoesNotExist()":[{"details":"Thrown when checking the owner or approved address for a non-existent NFT."}],"TotalSupplyOverflow()":[{"details":"Thrown when minting an amount of tokens that would overflow the max tokens."}],"TransferCallerNotOwnerNorApproved()":[{"details":"Thrown when transferring an NFT and the caller is not the owner or an approved operator."}],"TransferFromIncorrectOwner()":[{"details":"Thrown when transferring an NFT and the from address is not the current owner."}],"TransferToZeroAddress()":[{"details":"Thrown when attempting to transfer tokens to the zero address."}]},"events":{"Approval(address,address,uint256)":{"details":"Emitted when `amount` tokens is approved by `owner` to be used by `spender`."},"SkipNFTSet(address,bool)":{"details":"Emitted when `owner` sets their skipNFT flag to `status`."},"Transfer(address,address,uint256)":{"details":"Emitted when `amount` tokens is transferred from `from` to `to`."}},"kind":"dev","methods":{"allowance(address,address)":{"details":"Returns the amount of tokens that `spender` can spend on behalf of `owner`."},"approve(address,uint256)":{"details":"Sets `amount` as the allowance of `spender` over the caller's tokens. Emits a {Approval} event."},"balanceOf(address)":{"details":"Returns the amount of tokens owned by `owner`."},"decimals()":{"details":"Returns the decimals places of the token. Defaults to 18. Does not affect DN404's internal calculations. Will only affect the frontend UI on most protocols."},"getSkipNFT(address)":{"details":"Returns true if minting and transferring ERC20s to `owner` will skip minting NFTs. Returns false otherwise."},"mirrorERC721()":{"details":"Returns the address of the mirror NFT contract."},"name()":{"details":"Returns the name of the token."},"setSkipNFT(bool)":{"details":"Sets the caller's skipNFT flag to `skipNFT`. Returns true. Emits a {SkipNFTSet} event."},"symbol()":{"details":"Returns the symbol of the token."},"totalSupply()":{"details":"Returns the amount of tokens in existence."},"transfer(address,uint256)":{"details":"Transfer `amount` tokens from the caller to `to`. Will burn sender NFTs if balance after transfer is less than the amount required to support the current NFT balance. Will mint NFTs to `to` if the recipient's new balance supports additional NFTs ***AND*** the `to` address's skipNFT flag is set to false. Requirements: - `from` must at least have `amount`. Emits a {Transfer} event."},"transferFrom(address,address,uint256)":{"details":"Transfers `amount` tokens from `from` to `to`. Note: Does not update the allowance if it is the maximum uint256 value. Will burn sender NFTs if balance after transfer is less than the amount required to support the current NFT balance. Will mint NFTs to `to` if the recipient's new balance supports additional NFTs ***AND*** the `to` address's skipNFT flag is set to false. Requirements: - `from` must at least have `amount`. - The caller must have at least `amount` of allowance to transfer the tokens of `from`. Emits a {Transfer} event."}},"stateVariables":{"_ADDRESS_DATA_OVERRIDE_PERMIT2_FLAG":{"details":"The flag to denote that the address has overridden the default Permit2 allowance."},"_ADDRESS_DATA_SKIP_NFT_FLAG":{"details":"The flag to denote that the address should skip NFTs."},"_ADDRESS_DATA_SKIP_NFT_INITIALIZED_FLAG":{"details":"The flag to denote that the skip NFT flag is initialized."},"_APPROVAL_EVENT_SIGNATURE":{"details":"`keccak256(bytes(\"Approval(address,address,uint256)\"))`."},"_PERMIT2":{"details":"The canonical Permit2 address. For signature-based allowance granting for single transaction ERC20 `transferFrom`. To enable, override `_givePermit2DefaultInfiniteAllowance()`. [Github](https://github.com/Uniswap/permit2) [Etherscan](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)"},"_SKIP_NFT_SET_EVENT_SIGNATURE":{"details":"`keccak256(bytes(\"SkipNFTSet(address,bool)\"))`."},"_TRANSFER_EVENT_SIGNATURE":{"details":"`keccak256(bytes(\"Transfer(address,address,uint256)\"))`."}},"title":"DN404","version":1},"methodIdentifiers":{"allowance(address,address)":"0xdd62ed3e","approve(address,uint256)":"0x095ea7b3","balanceOf(address)":"0x70a08231","decimals()":"0x313ce567","getSkipNFT(address)":"0x274e430b","mirrorERC721()":"0x4ef41efc","name()":"0x06fdde03","setSkipNFT(bool)":"0x2a6a935d","symbol()":"0x95d89b41","totalSupply()":"0x18160ddd","transfer(address,uint256)":"0xa9059cbb","transferFrom(address,address,uint256)":"0x23b872dd"},"runtimeBytecode":{"bytecode":"0x"},"sourceId":"dn404/DN404.sol","sourcemap":"","userdoc":{"kind":"user","methods":{},"notice":"DN404 is a hybrid ERC20 and ERC721 implementation that mints and burns NFTs based on an account's ERC20 token balance.","version":1}}