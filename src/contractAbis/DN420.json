{"abi":[{"inputs":[],"name":"ArrayLengthsMismatch","type":"error"},{"inputs":[],"name":"DNAlreadyInitialized","type":"error"},{"inputs":[],"name":"DNNotInitialized","type":"error"},{"inputs":[],"name":"FnSelectorNotRecognized","type":"error"},{"inputs":[],"name":"InsufficientAllowance","type":"error"},{"inputs":[],"name":"InsufficientBalance","type":"error"},{"inputs":[],"name":"InvalidNFTAmount","type":"error"},{"inputs":[],"name":"InvalidUnit","type":"error"},{"inputs":[],"name":"NotOwnerNorApproved","type":"error"},{"inputs":[],"name":"TotalSupplyOverflow","type":"error"},{"inputs":[],"name":"TransferFromIncorrectOwner","type":"error"},{"inputs":[],"name":"TransferToNonERC1155ReceiverImplementer","type":"error"},{"inputs":[],"name":"TransferToZeroAddress","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"operator","type":"address"},{"indexed":false,"internalType":"bool","name":"isApproved","type":"bool"}],"name":"ApprovalForAll","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":false,"internalType":"uint256","name":"id","type":"uint256"}],"name":"OwnedCheckpointSet","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":false,"internalType":"bool","name":"status","type":"bool"}],"name":"SkipNFTSet","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"Transfer","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"operator","type":"address"},{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256[]","name":"ids","type":"uint256[]"},{"indexed":false,"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"name":"TransferBatch","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"operator","type":"address"},{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"id","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"TransferSingle","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"string","name":"value","type":"string"},{"indexed":true,"internalType":"uint256","name":"id","type":"uint256"}],"name":"URI","type":"event"},{"stateMutability":"payable","type":"fallback"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"getOwnedCheckpoint","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"getSkipNFT","outputs":[{"internalType":"bool","name":"result","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"operator","type":"address"}],"name":"isApprovedForAll","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"uint256","name":"id","type":"uint256"}],"name":"owns","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256[]","name":"ids","type":"uint256[]"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"safeBatchTransferNFTs","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"id","type":"uint256"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"safeTransferNFT","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"operator","type":"address"},{"internalType":"bool","name":"isApproved","type":"bool"}],"name":"setApprovalForAll","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"id","type":"uint256"}],"name":"setOwnedCheckpoint","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bool","name":"skipNFT","type":"bool"}],"name":"setSkipNFT","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"result","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"id","type":"uint256"}],"name":"uri","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"stateMutability":"payable","type":"receive"}],"contractName":"DN420","deploymentBytecode":{"bytecode":"0x"},"devdoc":{"author":"vectorized.eth (@optimizoor)Quit (@0xQuit)Michael Amadi (@AmadiMichaels)cygaar (@0xCygaar)Thomas (@0xjustadev)Harrison (@PopPunkOnChain)","details":"Note: - On-transfer token ID burning scheme:     * DN420: Largest token ID up to owned checkpoint (inclusive) first.     * DN404: Most recently acquired token ID first. - This implementation uses bitmap scans to find ERC1155 token IDs   to transfer / burn upon ERC20 transfers. - For long-term gas efficiency, please ensure that the maximum   supply of NFTs is bounded and not too big.   10k is fine; it will cost less than 100k gas to bitmap scan 10k bits.   Otherwise, users can still always call `setOwnedCheckpoint` to unblock. - A unit worth of ERC20 tokens equates to a deed to one NFT token.   The skip NFT status determines if this deed is automatically exercised.   An account can configure their skip NFT status.     * If `getSkipNFT(owner) == true`, ERC20 mints / transfers to `owner`       will NOT trigger NFT mints / transfers to `owner` (i.e. deeds are left unexercised).     * If `getSkipNFT(owner) == false`, ERC20 mints / transfers to `owner`       will trigger NFT mints / transfers to `owner`, until the NFT balance of `owner`       is equal to its ERC20 balance divided by the unit (rounded down). - Invariant: `_balanceOfNFT(owner) <= balanceOf(owner) / _unit()`. - The gas costs for automatic minting / transferring / burning of NFTs is O(n).   This can exceed the block gas limit.   Applications and users may need to break up large transfers into a few transactions. - This implementation uses safe transfers for automatic NFT transfers,   as all transfers require the recipient check by the ERC1155 spec. - The ERC20 token allowances and ERC1155 token / operator approvals are separate. - For MEV safety, users should NOT have concurrently open orders for the ERC20 and ERC1155.","errors":{"ArrayLengthsMismatch()":[{"details":"The lengths of the input arrays are not the same."}],"DNAlreadyInitialized()":[{"details":"Thrown when attempting to double-initialize the contract."}],"DNNotInitialized()":[{"details":"The contract has not been initialized."}],"FnSelectorNotRecognized()":[{"details":"The function selector is not recognized."}],"InsufficientAllowance()":[{"details":"Thrown when a spender attempts to transfer tokens with an insufficient allowance."}],"InsufficientBalance()":[{"details":"Thrown when attempting to transfer or burn more tokens than sender's balance."}],"InvalidNFTAmount()":[{"details":"The amount of ERC1155 NFT transferred per token must be 1."}],"InvalidUnit()":[{"details":"The unit must be greater than zero and less than `2**96`."}],"NotOwnerNorApproved()":[{"details":"Thrown when transferring an NFT and the caller is not the owner or an approved operator."}],"TotalSupplyOverflow()":[{"details":"Thrown when minting an amount of tokens that would overflow the max tokens."}],"TransferFromIncorrectOwner()":[{"details":"Thrown when transferring an NFT and the from address is not the current owner."}],"TransferToNonERC1155ReceiverImplementer()":[{"details":"Cannot safely transfer to a contract that does not implement the ERC1155Receiver interface."}],"TransferToZeroAddress()":[{"details":"Thrown when attempting to transfer tokens to the zero address."}]},"events":{"Approval(address,address,uint256)":{"details":"Emitted when `amount` tokens is approved by `owner` to be used by `spender`."},"ApprovalForAll(address,address,bool)":{"details":"Emitted when `owner` enables or disables `operator` to manage all of their tokens."},"OwnedCheckpointSet(address,uint256)":{"details":"Emitted when `owner` sets their owned checkpoint to `id`."},"SkipNFTSet(address,bool)":{"details":"Emitted when `owner` sets their skipNFT flag to `status`."},"Transfer(address,address,uint256)":{"details":"Emitted when `amount` tokens is transferred from `from` to `to`."},"TransferBatch(address,address,address,uint256[],uint256[])":{"details":"Emitted when `amounts` of token `ids` are transferred from `from` to `to` by `operator`."},"TransferSingle(address,address,address,uint256,uint256)":{"details":"Emitted when `amount` of token `id` is transferred from `from` to `to` by `operator`."},"URI(string,uint256)":{"details":"Emitted when the Uniform Resource Identifier (URI) for token `id` is updated to `value`. This event is not used in the base contract. You may need to emit this event depending on your URI logic. See: https://eips.ethereum.org/EIPS/eip-1155#metadata"}},"kind":"dev","methods":{"allowance(address,address)":{"details":"Returns the amount of ERC20 tokens that `spender` can spend on behalf of `owner`."},"approve(address,uint256)":{"details":"Sets `amount` as the allowance of `spender` over the caller's ERC20 tokens. Emits an ERC20 {Approval} event."},"balanceOf(address)":{"details":"Returns the amount of ERC20 tokens owned by `owner`."},"decimals()":{"details":"Returns the decimals places of the ERC20 token. Always 18."},"getOwnedCheckpoint(address)":{"details":"Returns the owned checkpoint of `owner`."},"getSkipNFT(address)":{"details":"Returns true if minting and transferring ERC20s to `owner` will skip minting NFTs. Returns false otherwise."},"isApprovedForAll(address,address)":{"details":"Returns whether `operator` is approved to manage the ERC1155 tokens of `owner`."},"name()":{"details":"Returns the name of the token."},"owns(address,uint256)":{"details":"Returns if `owner` owns ERC1155 `id`."},"safeBatchTransferNFTs(address,address,uint256[],bytes)":{"details":"Transfers the ERC1155 NFTs at `ids` from `from` to `to`."},"safeTransferNFT(address,address,uint256,bytes)":{"details":"Transfers the ERC1155 NFT at `id` from `from` to `to`."},"setApprovalForAll(address,bool)":{"details":"Sets whether `operator` is approved to manage the ERC1155 tokens of the caller. Emits a {ApprovalForAll} event."},"setOwnedCheckpoint(uint256)":{"details":"Just in case the collection gets too large and the caller needs to set their owned checkpoint manually to skip large bitmap scans for automatic ERC1155 NFT burns upon ERC20 transfers."},"setSkipNFT(bool)":{"details":"Sets the caller's skipNFT flag to `skipNFT`. Returns true. Emits a {SkipNFTSet} event."},"supportsInterface(bytes4)":{"details":"Returns true if this contract implements the interface defined by `interfaceId`. See: https://eips.ethereum.org/EIPS/eip-165 This function call must use less than 30000 gas."},"symbol()":{"details":"Returns the symbol of the token."},"totalSupply()":{"details":"Returns the amount of ERC20 tokens in existence."},"transfer(address,uint256)":{"details":"Transfer `amount` ERC20 tokens from the caller to `to`. Will burn sender's ERC1155 NFTs if balance after transfer is less than the amount required to support the current NFT balance. Will mint ERC1155 NFTs to `to` if the recipient's new balance supports additional ERC1155 NFTs ***AND*** the `to` address's skipNFT flag is set to false. Requirements: - `from` must at least have `amount` ERC20 tokens. Emits an ERC1155 {TransferBatch} event for direct transfers (if any). Emits an ERC1155 {TransferBatch} event for mints (if any). Emits an ERC1155 {TransferBatch} event for burns (if any). Emits an ERC20 {Transfer} event."},"transferFrom(address,address,uint256)":{"details":"Transfers `amount` ERC20 tokens from `from` to `to`. Note: Does not update the ERC20 allowance if it is the maximum uint256 value. Will burn sender ERC1155 NFTs if balance after transfer is less than the amount required to support the current ERC1155 NFT balance. Will mint ERC1155 NFTs to `to` if the recipient's new balance supports additional ERC1155 NFTs ***AND*** the `to` address's skipNFT flag is set to false. Requirements: - `from` must at least have `amount` ERC20 tokens. - The caller must have at least `amount` of ERC20 allowance to transfer the tokens of `from`. Emits a {Transfer} event."},"uri(uint256)":{"details":"Returns the URI for token `id`. You can either return the same templated URI for all token IDs, (e.g. \"https://example.com/api/{id}.json\"), or return a unique URI for each `id`. See: https://eips.ethereum.org/EIPS/eip-1155#metadata"}},"stateVariables":{"_ADDRESS_DATA_OVERRIDE_PERMIT2_FLAG":{"details":"The flag to denote that the address has overridden the default Permit2 allowance."},"_ADDRESS_DATA_SKIP_NFT_FLAG":{"details":"The flag to denote that the address should skip NFTs."},"_ADDRESS_DATA_SKIP_NFT_INITIALIZED_FLAG":{"details":"The flag to denote that the skip NFT flag is initialized."},"_APPROVAL_EVENT_SIGNATURE":{"details":"`keccak256(bytes(\"Approval(address,address,uint256)\"))`."},"_APPROVAL_FOR_ALL_EVENT_SIGNATURE":{"details":"`keccak256(bytes(\"ApprovalForAll(address,address,bool)\"))`."},"_PERMIT2":{"details":"The canonical Permit2 address. For signature-based allowance granting for single transaction ERC20 `transferFrom`. To enable, override `_givePermit2DefaultInfiniteAllowance()`. [Github](https://github.com/Uniswap/permit2) [Etherscan](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)"},"_SKIP_NFT_SET_EVENT_SIGNATURE":{"details":"`keccak256(bytes(\"SkipNFTSet(address,bool)\"))`."},"_TRANSFER_BATCH_EVENT_SIGNATURE":{"details":"`keccak256(bytes(\"TransferBatch(address,address,address,uint256[],uint256[])\"))`."},"_TRANSFER_EVENT_SIGNATURE":{"details":"`keccak256(bytes(\"Transfer(address,address,uint256)\"))`."},"_TRANSFER_SINGLE_EVENT_SIGNATURE":{"details":"`keccak256(bytes(\"TransferSingle(address,address,address,uint256,uint256)\"))`."}},"title":"DN420","version":1},"methodIdentifiers":{"allowance(address,address)":"0xdd62ed3e","approve(address,uint256)":"0x095ea7b3","balanceOf(address)":"0x70a08231","decimals()":"0x313ce567","getOwnedCheckpoint(address)":"0x3e100f6e","getSkipNFT(address)":"0x274e430b","isApprovedForAll(address,address)":"0xe985e9c5","name()":"0x06fdde03","owns(address,uint256)":"0x818d4b5d","safeBatchTransferNFTs(address,address,uint256[],bytes)":"0xdb8a5600","safeTransferNFT(address,address,uint256,bytes)":"0xaab6a17b","setApprovalForAll(address,bool)":"0xa22cb465","setOwnedCheckpoint(uint256)":"0x29a96532","setSkipNFT(bool)":"0x2a6a935d","supportsInterface(bytes4)":"0x01ffc9a7","symbol()":"0x95d89b41","totalSupply()":"0x18160ddd","transfer(address,uint256)":"0xa9059cbb","transferFrom(address,address,uint256)":"0x23b872dd","uri(uint256)":"0x0e89341c"},"runtimeBytecode":{"bytecode":"0x"},"sourceId":"dn404/DN420.sol","sourcemap":"","userdoc":{"kind":"user","methods":{},"notice":"DN420 is a fully standard compliant, single-contract, ERC20 and ERC1155 chimera implementation that mints and burns NFTs based on an account's ERC20 token balance. This contract has not yet been audited. USE AT YOUR OWN RISK!","version":1}}